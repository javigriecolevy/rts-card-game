Perfect â€” letâ€™s wire the entire flow together so you can:

Load cards from GameState

Display them in HandView

Click a card

See the click reach GameUI

Queue a PlayCardCommand

This will give you your first fully playable interaction loop.

ğŸ§± Assumptions

Your GameState has something like:

game_state.hands[player_id]              # Array[int]
game_state.card_instances[id]            # CardInstance
game_state.card_instances[id].definition # CardDefinition


And CardDefinition contains:

display_name
cost

1ï¸âƒ£ GameUI.gd (Root Controller)

This connects everything together.

extends Control

@onready var hand_view: HandView = $HandView
@onready var tick_manager = get_node("/root/TickManager")

var player_id := 1

func _ready():
    hand_view.connect("card_selected", Callable(self, "_on_card_selected"))

    # Initial refresh
    _refresh_ui()

func _process(_delta):
    # Refresh UI each frame for prototype
    _refresh_ui()

func _refresh_ui():
    var game_state = tick_manager.game_state
    var hand_cards = game_state.hands[player_id]
    hand_view.update_hand(hand_cards, game_state)

func _on_card_selected(card_instance_id: int):
    print("Card clicked: ", card_instance_id)

    var game_state = tick_manager.game_state

    var command = PlayCardCommand.new(
        game_state.tick + 1,
        player_id,
        card_instance_id,
        -1 # target for now
    )

    tick_manager.command_queue.append(command)

2ï¸âƒ£ HandView.gd (Already Mostly Done)

Updated to pass card definition properly:

extends Control
class_name HandView

@onready var card_container: HBoxContainer = $CardContainer
@onready var CardViewScene: PackedScene = preload("res://ui/CardView.tscn")

signal card_selected(card_instance_id)

var cards: Array[int] = []
var game_state = null

func update_hand(new_cards: Array[int], gs) -> void:
    cards = new_cards
    game_state = gs
    _refresh_card_views()

func _refresh_card_views():
    for child in card_container.get_children():
        child.queue_free()

    for card_instance_id in cards:
        var instance = game_state.card_instances[card_instance_id]

        var card_view: CardView = CardViewScene.instantiate()
        card_view.card_instance_id = instance.id

        card_view.set_card_data({
            "name": instance.definition.display_name,
            "cost": instance.definition.cost
        })

        card_view.connect("clicked", Callable(self, "_on_card_clicked"))
        card_container.add_child(card_view)

func _on_card_clicked(card_instance_id: int):
    emit_signal("card_selected", card_instance_id)

3ï¸âƒ£ CardView.gd
extends Control
class_name CardView

signal clicked(card_instance_id)

var card_instance_id: int = -1

@onready var name_label: Label = $NameLabel
@onready var cost_label: Label = $CostLabel

func _ready():
    mouse_filter = Control.MOUSE_FILTER_STOP
    connect("gui_input", Callable(self, "_on_gui_input"))

func set_card_data(data: Dictionary) -> void:
    name_label.text = data.get("name", "Unknown")
    cost_label.text = str(data.get("cost", "?"))

func _on_gui_input(event: InputEvent) -> void:
    if event is InputEventMouseButton \
    and event.pressed \
    and event.button_index == MOUSE_BUTTON_LEFT:
        emit_signal("clicked", card_instance_id)

ğŸ”„ What Now Happens

_process() refreshes UI

HandView reads from GameState

CardView instances are created

You click a card

CardView emits "clicked"

HandView emits "card_selected"

GameUI receives it

PlayCardCommand is queued

TickManager processes it

EventResolver runs

GameState updates

UI refreshes

Thatâ€™s your full loop.

ğŸ¯ What You Should See

Cards appear in hand

Clicking prints the card ID

Card disappears if cost is valid and engine processes play

Minion appears on board (if your board UI is connected)

If that works, your engine and UI contract is correct.

ğŸš€ Next Step (Recommended)

Now that clicking works, the next big addition should be:

Target selection system

Because:

Battlecry needs targets

Attacks need targets

Spells need targets

And that changes UI flow significantly.

If you want, Iâ€™ll show you how to build a simple â€œselection state machineâ€ in GameUI next.
